
第十五章 面向对象程序设计

#面向对象程序设计的核心思想是数据抽象、继承和动态绑定

#C++11 新标准允许在派生类中显式地注明它将使用哪个成员函数改写基类的虚函数，具体措施是在该函数的形参列表后增加一个override关键字

#在C++语言中，当我们使用基类的引用或指针调用一个虚函数时将发生动态绑定

#关键字virtual只能出现在类内部的声明语句之前而不能用于类外部的函数定义。

#派生列表中的访问说明符的作用是为了说明派生类从基类继承来的成员是否对派生类的用户可见

#如果派生类不重写基类的虚函数，则它将继承基类的版本

#在一个对象中，继承自基类的部分和派生类自定义的部分不一定连续存储

#可以把派生类对象的引用或指针用在需要基类对象引用或指针的地方

#每个类控制它自己的成员的初始化过程

#派生类初始化过程：首先初始化基类的部分，然后按照声明的顺序依次初始化派生类的成员

#如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义

#如果一个类想被用作基类，那么它必须已经定义，而非仅仅声明

#防止继承发生
	在类名后面跟一个关键字final

#静态类型(static type)与动态类型(dynamic type)
表达式的静态类型在编译时就是已知的；
动态类型往往是变量或表达式表示的内存中的对象的模型

#
从派生类向基类的类型转换只对指针或引用类型有效；
基类向派生类不存在隐式类型转换

#当使用基类的引用或指针调用一个虚成员函数是会执行动态绑定；当通过一个普通类型的表达式调用虚函数时，在编译的时候就能确定到底调用 哪一个版本的虚函数。

# polymorphism 多态性，即“多种形式”

# 当且仅当对通过指针或引用调用虚函数时，才会在运行期间解析该调用，也只有在这种情况下对象的动态类型才有可能与静态类型不同

# 派生类在重写虚函数的时候可以在函数声明前加注virtual关键字，当然，也可以不加，这其中的区别在于，如果加注了virtual，则这个函数在所有它的派生类中都是虚函数

#虽然不能创建抽象基类的对象，但是必须为它定义构造函数，因为它的派生类指望着用它来初始化虚基类的成员呢

#含有纯虚函数的类就是抽象基类了

#保护继承有一条特别的性质，即在派生类中只能通过派生类的对象访问该对象包含的基类部分的受保护成员

#某个类对其继承而来的成员的访问权限受到两个因素影响：一是该成员在基类中的访问权限说明符，二是在派生类的派生列表中的访问说明符

#派生访问说明符对于派生类的成员及友元能否访问其直接基类的成员没什么影响。对基类成员的访问权限只与基类中的访问说明符有关。注意是派生类的成员和友元对基类成员的访问权限只与基类中的访问说明符有关。

#派生访问说明符是为了控制派生类用户对基类成员的访问权限。注意是派生类用户（派生类对象、派生类的派生类等）的访问权限

#公有派生，则派生类用户的访问权限就是基类中声明的那样

#派生类向基类转换的可访问性

总的来说，对于代码中的某个给定节点，如果基类的公有成员是可访问的，则派生类向基类的类型转换也是可访问的。

#类的设计与受保护的成员
基类应该将其接口成员声明为公有的；同时将属于其实现部分分成两组：一组可供派生类访问，声明为protected;另一组只能由基类及基类的友元访问，声明为private.

#友元与继承
友元关系不能继承。基类的友元在访问派生类成员时不具有特殊性；派生类的友元也不能随意访问基类的成员。

#判断友元访问权限时，分清要访问的对象属于哪个类，然后根据该友元对于这个类的访问权限判断能否访问。

#不能继承友元关系；每个类负责控制各自成员的访问权限。

#默认的继承保护级别
使用class关键字定义的派生类是私有继承的

#使用struct和class定义的类的差别（仅有两个差别）
1.	struct成员默认访问说明符是public
	class成员默认访问说明符是private
2.	使用struct定义派生类时，默认派生访问说明符是public，class则是private

#派生类向基类转换的可访问性

首先应该分清访问的主体，即谁来访问

我将主体分为三类：
类的成员或友元
类的对象
派生类

对于派生类的对象来说，只有派生类是public 继承自基类时，才能使用派生类对象向基类的转换

对于派生类的派生类来说（派生类的派生类也是派生类的用户），只有派生类是public 继承自基类时，派生类的派生类的对象才能使用向基类的转换

无论派生类如何继承自基类，派生类的成员及友元都能使用向基类的转换

对于派生类的派生类的成员和友元来说，是否能向基类转换取决于派生类的继承方式，如果派生类public或protected继承自基类，那么派生类的派生类的成员和友元仍然可以访问基类的保护和公有成员，就可以向基类转换

如果派生类private继承自基类，那么派生类的派生类的成员或友元就不能访问基类的任何成员了，自然不能向基类转换。

总的来说，如果想在某个代码节点使用向基类的转换，应该判断在当前节点（派生类对象、派生类成员或友元、派生类的派生类的对象、派生类的派生类的成员或友元）是否能够访问基类的公有成员，下面来一一分析：

1.派生类的对象
由于派生类对象对基类的访问权限由派生访问说明符控制，所以当且仅当派生类是public继承自基类时，派生类的对象才能访问基类的公有成员，才能向基类转换。

2.派生类的成员或友元
派生类的成员或友元对基类的访问权限不受派生访问说明符控制，所以无论派生类如何继承自基类，派生类的成员或友元总能访问基类的公有成员，也总能向基类转换。

3.派生类的派生类的对象
这时候，这个对象对基类的访问权限由两个派生访问说明符控制，所以只有派生类public继承自基类，派生类的派生类public继承自派生类，派生类的派生类的对象才能向基类转换。

4.派生类的派生类的成员和友元
此时，这些成员和友元对基类的访问权限仅由派生类如何继承自基类决定，当派生类public或protected继承自基类时，基类的公有成员对于派生类的派生类的成员和友元来说是可访问的，因此可以使用向基类的转换。



#继承中的类作用域

只需记住一点：派生类的作用域嵌套在基类作用域之中，通俗理解就是基类作用域包含派生类的作用域。
使用基类指针指向派生类对象时，不能通过这个指针直接调用派生类的成员

#名字冲突
派生类的成员将隐藏同名的基类成员

这就像在代码块内部定义的变量会暂时隐藏代码块外的同名变量一样

如果需要在这种情况下使用被隐藏的成员，应该使用作用域运算符


#除了覆盖继承而来的虚函数之外，派生类最好不要重用定义在基类中的名字

#C++中函数调用过程

obj.mem()

1.首先确定obj的静态类型，如果obj是指针，就确定声明指针时写的那个类，如果是个对象，自然就是对象的类，这里obj是一个类

2.在静态类型对应的类中查找mem,如果找不到就依次在直接基类中不断查找直至到达继承链的顶端，如果在那里也找不到，编译器就报错

3.然后进行常规的类型检查，如果是虚函数还要判断该调用哪个版本

#基类应该定义一个虚析构函数

#只要基类中的析构函数是虚函数，就能确保执行delete操作时调用正确的析构函数

#一条经验准则：如果一个类需要析构函数，那么它也同样需要拷贝和赋值操作。

#一个派生类的构造函数调用其直接基类的构造函数，初始化时，直接基类的构造函数首先初始化基类的成员，然后再执行派生类的构造函数。

#类有拷贝、赋值、移动和销毁等操作

#
拷贝构造函数
移动构造函数
拷贝赋值运算符
移动赋值运算符

拷贝/移动构造函数定义了当用同类型的另一个对象初始化本对象时作什么

拷贝/移动赋值运算符定义了当用同类型的另一个对象赋值给另一个对象时作什么

#移动操作是新标准引入的一种操作

#拷贝构造函数的第一个参数必须是一个const &类型，通常都会隐式调用拷贝构造函数，因此它不应该是explicit的

#




第十三章 拷贝控制

#析构函数
析构函数不接受任何参数，所以不能被重载，每个类只有唯一一个析构函数。

#构造函数和析构函数初始化/销毁的顺序

构造函数先按成员在类中出现的顺序对成员进行初始化，然后执行函数体

析构函数先执行函数体，然后按成员初始化的逆序销毁成员


#隐式销毁一个内置的指针类型的成员不会delete它所指向的对象

#注意成员并不是在析构函数体里被销毁的，它们是在析构函数体运行完之后的销毁阶段被销毁的

#有三个基本操作可以控制类的拷贝操作：拷贝构造函数、拷贝赋值运算符和析构函数

#一个经验是：需要析构函数的类通常也需要拷贝构造函数和拷贝赋值运算符。需要析构函数说明类中定义了自动执行销毁过程时候无法彻底“清理干净”的成员，那么当使用拷贝构造和赋值运算的时候自然也不能自动完成相应的操作，所以自然需要自定义拷贝构造函数和拷贝赋值运算符

#使用拷贝操作的类也需要赋值操作，反之亦然

#大多数类应该定义默认构造函数、拷贝构造函数和拷贝赋值运算符，无论是显式的还是隐式的

#
对于析构函数已删除的类型，不能定义该类型的变量或释放指向该类型对象的指针

对于这种类，不能定义它的对象，但是可以动态分配这种类型的对象，即new，不知道有没有利用这一特性的骚操作？

#
本质上来说，当不可能拷贝、赋值或销毁类的成员时，类的合成拷贝控制成员就被定义为删除的



#希望阻止拷贝的类应该使用=delete来定义它们自己的拷贝构造函数和拷贝赋值运算符

#定义拷贝控制操作时有两种选择，一种是使类的行为像值，另一种是使类的行为像指针

#实现类的类值拷贝行为

注意要在拷贝赋值运算符内释放对象之前动态分配的内存，而拷贝构造函数不需要，因为拷贝构造函数负责对象初始化，在调用它的时候对象还没有已经初始化的成员，自然就不会有已经动态分配的内存；
拷贝赋值运算符

#
编写赋值运算符时有两点需要记住：
1.如果将一个对象赋予它自身，赋值运算符必须能正常工作

2.大多数赋值运算符组合了析构函数和拷贝构造函数的工作

编写赋值运算符时，一个好的模式是先将右侧运算对象先拷贝到一个局部临时对象中，当拷贝完成后销毁左侧运算对象的现有成员就是安全的了。然后将临时对象拷贝到左侧运算对象的成员中

#引用计数

 	除了拷贝构造函数，每个构造函数创建一个引用计数。
	拷贝构造函数递增对象的计数器
	拷贝赋值运算符递增右侧对象的计数器，递减左侧对象的计数器
	析构函数递减计数器

#一个要解决的问题是在哪里保存计数器
一种方法是将计数器保存在动态内存中，当创建一个对象时分配一个新的计数器，当拷贝或赋值对象时，拷贝计数器指针，这样就能使副本和原对象只想相同的计数器

#
交换操作swap在需要进行排序的类中特别有用

#拷贝赋值运算符通常执行拷贝构造函数和析构函数中的工作，这种情况下，公共的工作应该放在private的工具函数中完成

#动态内存管理

# move 函数定义在utility头文件

# 


######################################################
13.5节练习不会做，开始看12章动态内存管理，看会了再来做                    ######################################################


第十二章 动态内存

#shared_ptr、unique_ptr和weak_ptr三种类型都定义在memory头文件中

#在一个条件判断中使用只能指针就是判断它是否为空

#
如果shared_ptr保存在一个容器中，后来不再需要全部元素，而只使用其中一部分，要记得用erase删除不需要的那些元素

#




第二章 变量和基本类型

#
不要混用有符号和无符号类型

#
整型字面值

十进制 
八进制 		以0开头 
十六进制 	以0x开头

#
nullptr是指针字面值

#
列表初始化（list initialization）

#
引用在声明的时候必须初始化

#
引用即别名

#
默认情况下，const对象仅在文件内有效

#
不初始化const变量是非法的

#
允许使用常量引用以用非常量对象，不允许使用非常量引用引用常量对象

#
常量表达式是指值不会改变并且在编译过程中就能得到计算结果的表达式
C++11允许将变量声明为constexpr 类型以便由编译器来验证变量的值是否是一个常量表达式。

#
一个constexpr指针的初始值必须是nullptr或者0，或者是存储与某个固定地址中的对象。

#
别名声明（alias declaration）
using SI = Sales_item;

#
auto一般会忽略顶层const，保留底层const

#
decltype类型指示符
decltype用来获得一个表达式的类型

decltype(f()) sum = x;

sum是f()返回值的类型

#
decltype((variable))  双层括号的结果永远是引用
decltype(variable)  结果只有当variable本身就是一个引用时才是引用


第三章 字符串、向量和数组

#

using namespace::space

#
头文件中不应包含using声明

#
string s(10,'c'); //s的内容是cccccccccc

#
使用等号初始化对象，实际上执行是是拷贝初始化（copy initialization）
不使用等号，执行直接初始化（direct initialization）

#
如果想读取一整行，包括空白符，应该使用getline函数

#
string::size_type类型

#
auto len = line.size(); //len 的类型是string::size_type

#
如果一条表达式中已经有了size()函数就不要在使用int了，这样可以避免混用int和unsigned可能带来的问题

#
标准库允许把字符字面值和字符串字面值转换成string对象

#
字符串字面值和string是不同的类型

#
string 类的输入运算符>> 在遇到空白符的时候结束读取

getline 不会在空白符处停止读取

#
使用下标访问空string会引发不可预知的后果

#
理解数组声明的关键是从数组的名字开始按照由内向外的顺序阅读

#
尽管C++支持C风格字符串，但在C++程序中最好还是不要使用它们。

#
strlen函数返回字符串长度，不包含空字符


第四章 表达式

#
cout << i << ++i <<endl; should never appear in your code.

#
溢出，计算的结果超出该类型所能表达的范围时就会产生溢出

#
环绕（wrapped around）

#
赋值运算满足右结合律
 
#
递增/递减运算符  前置版本将对象本身作为左值返回，后置版本则将对象原始值的副本作为右值返回

除非必须，否则不用递增递减运算符的后置版本

#
*ptr++ 输出ptr当前指向的值并将ptr向前移动一个元素

#
建议仅将位运算符用于处理无符号整型。

#
(NO27<<27) | bits

1000 1110

0000 0011
0000 0111

#
sizeof 不会把数组名当作指针来处理
sizeof 对string对象或vector对象执行sizeof操作只返回该类型固定部分的大小，不会计算对象中的元素占了多少空间

#
隐式类型转换，在大多数表达式中，比int类型小的整型值首先提升为较大的整数类型。

#
整型提升(integral promotion)负责把小整数类型转换成较大是整数类型。

#
强制类型转换
static_cast
dynamic_cast
const_cast
reinterpret_cast

#
4.12节是运算符优先级表


第五章 语句

#
switch 中的case标签必须是整型常量表达式

#
任何两个标签的值不能相同

#
一般不要省略case分支最后的break语句。

#
想到利用switch语句特性的一种可能的场景。
需要统计某个范围内的数字出现的次数，比如要统计小于5、6、7、8、9的数字出现的次数，显然，并分别以less_5 、less_6 、less_7 、less_8 、less_9计数，那么可以用switch语句这样写：
	switch(value)
	{
		case 5:
			++less_6;
		case 6:
			++less_7;
		case 7:
			++less_8;
		case 8:
			++less_9;
		break;
	}

这个语句可能并没有什么用，是突然想到的，记录一下。

#
switch语句内部不应该定义并初始化变量，因为switch语句可能会跳过它的初始化。

#
do while语句不允许在条件部分定义变量

#
不要在程序中使用goto语句，因为它使得程序既难理解又难修改

#
throw表达式，异常检测部分使用throw表达式来表示它遇到了无法处理的问题，throw语句引发异常

try语句块，使用try语句块处理异常。try语句块以try关键字开始，后接一个或多个catch子句，catch子句处理异常（exception handler）。

异常类（exception class），用于在throw和相关catch子句之间传递异常信息

#
5.6.3 P176 标准异常类

第六章 函数

#
调用运算符（call operator）

#
函数调用完成两项工作：一是用实参初始化形参，二是将控制权转移给被调函数。此时，主调函数(calling function)的执行被暂时中断，被调函数(called function)开始执行。

#
C++中，名字由作用域，对象有生命周期。

#
局部对象：
自动对象与局部静态对象

#
函数声明也称为函数原型（function prototype）

#
在C++中建议使用引用类型的形参代替指针

#
常量引用可以使用字面值初始化
const int &r2 = 42;

#
C++允许将变量定义成数组的引用。

int (&arr)[10]; //数组的引用，数组长度为10
int &arr[10];	//arr是一个长度为10的数组，每一个数组元素都是int&

#
int main(int argc,char **argv);
注意：argc中包含了程序名的那一项

#
在讲到含有可变形参的函数时提到的一个应用是输出错误信息的程序。

#
C++11提供两种方法实现变参数函数，一是initializer_list的便准库类型，但是它只适用于所有实参类型相同的情况，二是使用可变参数模板。

#
initializer_list对象中的元素永远是常量值，无法改变initializer_list对象中元素的值

#
PODType ： POD (Plain Old Data) type

#
不要返回局部对象的引用或指针

#
































































	




























