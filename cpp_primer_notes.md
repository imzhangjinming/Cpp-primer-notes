# 第七章 类

* 构造和赋值是两个不同的概念

* 构造函数的初始值有时候必不可少，因为有些成员，如**const**、**引用**等，必须进行初始化。

* 成员初始化的顺序是它们在类中出现的顺序

* 如果一个构造函数为**所有**的参数都提供了默认实参，则它实际上也定义了默认构造函数

* exercise 7.36
```C++
MyClass(std::istream& c = std::cin);
```

* 委托构造函数(delegating constructor)

* 隐式的类类型转换只允许进行一步
* 将构造函数声明为`explicit`可以阻止隐式类类型转换，`explicit`只对一个实参的构造函数有效，只能在类内声明构造函数时使用，在类外定义的时候就不需要重复了
* 可以用`static`关键字声明类的静态成员，静态成员由类拥有，而不是为对象所拥有
* 即使一个常量静态数据成员在类内部被初始化了，通常情况下也应该在类的外部定义一下该成员
* 静态成员可以是不完全类型

```C++
class Bar{
public:
	//...
private:
	static Bar mem1;	//正确：静态成员可以是不完全类型
	Bar *mem2;			//正确：指针成员可以是不完全类型
	Bar mem3;			//错误：数据成员必须是完全类型
};
```

* 静态成员可以作为默认实参

# 第八章 IO库

* IO库类型和头文件 

 |头文件 | 类型|   
 :---: | :---:  
 iostream | istream ostream iostream  
 fstream | iftream ofstream fstream   
 sstream | istringstream ostringstream stringstream 
 
* IO对象无**拷贝**或**赋值**
* 由于IO对象无法进行拷贝或赋值，所以不能将形参或返回类型设置为流类型。通常以**引用**方式传递和返回流。读写一个IO对象会改变其状态，因此传递和返回的引用不能是`const`的。
* 一个流一旦发生错误，其上后续的IO操作也会失败。
* 每个输出流管理一个缓冲区，缓冲技术主要是为了提升效率，因为单一的写操作可能会很费时，将多个写操作合并成一个会节省很多开销。
* `std::endl` 可以显式刷新缓冲区
* `std::endl` `std::flush` `std::ends`都可以显式刷新缓冲区，但是它们的附加符号不同
* `unitbuf` 和 `nounitbuf`
* `tie` 可以用来关联流
* 一个`fstream`对象被销毁时，`close`会被自动调用
* 保留被`ofstream`打开的文件中已有的数据的唯一方法是显式指定`app`或`in`模式

# 第九章 顺序容器
* 

  











  











