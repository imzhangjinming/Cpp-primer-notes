# 第七章 类

* 构造和赋值是两个不同的概念

* 构造函数的初始值有时候必不可少，因为有些成员，如**const**、**引用**等，必须进行初始化。

* 成员初始化的顺序是它们在类中出现的顺序

* 如果一个构造函数为**所有**的参数都提供了默认实参，则它实际上也定义了默认构造函数

* exercise 7.36
```C++
MyClass(std::istream& c = std::cin);
```

* 委托构造函数(delegating constructor)

* 隐式的类类型转换只允许进行一步
* 将构造函数声明为`explicit`可以阻止隐式类类型转换，`explicit`只对一个实参的构造函数有效，只能在类内声明构造函数时使用，在类外定义的时候就不需要重复了
* 可以用`static`关键字声明类的静态成员，静态成员由类拥有，而不是为对象所拥有
* 即使一个常量静态数据成员在类内部被初始化了，通常情况下也应该在类的外部定义一下该成员
* 静态成员可以是不完全类型

```C++
class Bar{
public:
	//...
private:
	static Bar mem1;	//正确：静态成员可以是不完全类型
	Bar *mem2;			//正确：指针成员可以是不完全类型
	Bar mem3;			//错误：数据成员必须是完全类型
};
```

* 静态成员可以作为默认实参

# 第八章 IO库  

* IO库类型和头文件   

|头文件 | 类型|
|:---: | :---: |
|iostream | istream ostream iostream|
|fstream | iftream ofstream fstream|
|sstream | istringstream ostringstream stringstream|

* IO对象无**拷贝**或**赋值**  
* 由于IO对象无法进行拷贝或赋值，所以不能将形参或返回类型设置为流类型。通常以**引用**方式传递和返回流。读写一个IO对象会改变其状态，因此传递和返回的引用不能是`const`的。  
* 一个流一旦发生错误，其上后续的IO操作也会失败。  
* 每个输出流管理一个缓冲区，缓冲技术主要是为了提升效率，因为单一的写操作可能会很费时，将多个写操作合并成一个会节省很多开销。  
* `std::endl` 可以显式刷新缓冲区  
* `std::endl` `std::flush` `std::ends`都可以显式刷新缓冲区，但是它们的附加符号不同  
* `unitbuf` 和 `nounitbuf`  
* `tie` 可以用来关联流  
* 一个`fstream`对象被销毁时，`close`会被自动调用  
* 保留被`ofstream`打开的文件中已有的数据的唯一方法是显式指定`app`或`in`模式  

# 第九章 顺序容器  
* 顺序容器类型  
	`vector` `deque` `list` `forward_list` `array` `string`  
* `string` 和 `vector` 的元素保存在连续的内存空间中  
* 通常，使用  **`vector`**是最好的选择，除非有很好的理由选择其他容器  
* exercise 9.2  
	`list<deque<int>> L;`  
* `forward_list`迭代器不支持递减运算符  
* 构成迭代器范围的迭代器的限制  
	* `begin` 与 `end` 相等，则范围为空  
	* `begin` 与 `end` 不等，则范围至少包含一个元素，且`begin` 指向该范围中的第一个元素  
	* 可以对`begin` 递增若干次，使得 `begin == end`   
* exercise 9.7  
	`vector<int>::sizetype i;`  
* exercise 9.8  
	`list<string>::const_iterator i;`  
	`list<string>::iterator i;`  
* 当 `auto` 与 `begin` 或 `end` 结合使用时，获得的迭代器类型依赖于容器类型  
* exercise 9.10
	`it1 : iterator`  
	`it2 : const_iterator`  
	`it3 : const_iterator`  
	`it4 : const_iterator`  
* 只有顺序容器的构造函数才接受大小参数，关联容器并不支持  
* 需要交换两个相同类型的容器的内容时，`swap`通常比拷贝快得多  
* 顺序容器（ `array`  除外）定义了一个名为`assign`的成员，允许我们从一个不同但相容的类型赋值，或者从容器的一个子序列赋值。  
* 传递给`assign`的迭代器不能指向调用`assign`的容器（即不能指向它自身？）  
* 除了`string`外，指向容器的迭代器、引用和指针在`swap`操作后不会失效，但是它们指向的元素已经属于不同的容器。  
* 统一使用非成员版本的`swap`是一个好习惯  
* 比较两个容器实际上是进行元素的逐对比较。所以容器的关系运算符使用元素的关系运算符完成比较  
* 向一个`vector`、`string`、`deque`插入元素会使所有指向容器的迭代器、引用和指针都失效  
* `emplace`成员使用传递给它的参数在容器管理的内存中直接构造元素，省去了使用`push`或`insert`时拷贝对象所花费的时间  
* 不能递减`forward_list`迭代器  
* `string` `vector` `deque` `array` 都提供下标运算符  
* `forward_list`部分没有仔细看  
* 使用迭代器添加元素或者删除元素可能会使迭代器失效，因此必须保证每次操作完成后迭代器被**重新定位**  
* `end`返回的迭代器很容易失效，所以最好不要保存`end`返回的迭代器，或者记得实时更新保存`end`返回值的迭代器  
* `vector` `string` `deque` 支持 `shrink_to_fit` 操作，将 `capacity` 减少为与 `size` 相同的大小  
* `string` 的额外操作部分没有细看，需要用到时再回来查吧  
* 容器**适配器**（`adaptor`）
* 每个容器适配器都基于底层容器类型的操作定义了自己的特殊操作，我们**只能**使用适配器操作，不能使用底层容器的操作  

# 第十章 泛型算法（generic algorithm）  

* 泛型算法永远不会改变底层容器的大小。算法可能改变容器中保存的元素的值，也可能在容器内移动元素，但永远不会直接添加或删除元素。（因为这些操作可能会使迭代器失效）  

* 对书中提到的算法做一个简单记录  

|算法名称|功能|
|:---:|:---:|
|find|在一个未排序的元素序列中查找一个特定元素|
|count|返回指定元素序列中指定值出现的次数|
|accumulate|计算指定元素序列中所有元素的和|
|equal|用于确定两个序列是否保存相同的值|
|fill  fill_n|将范围内的元素赋为给定值|
|copy|复制|
|replace|替换|
|sort|排序|

* 只接受一个单一迭代器来表示第二个序列的算法，都假定第二个序列至少与第一个序列一样长  
* 向目的位置迭代器写入数据的算法假定目的位置足够大，能容纳要写入的元素  
* **可调用对象** （callable object）。
* 四种可调用对象
	* 函数  
	* 函数指针  
	* 重载了函数调用运算符的类  
	* lambda表达式  
* 一个lambda表达式表示一个可调用的代码单元，可以将其理解为一个未命名的内联函数  
* lambda必须使用尾置返回类型  
* lambda可以省略参数列表和返回类型，但必须永远包含捕获列表和函数体  
* 只对lambda所在函数中定义的非static变量使用捕获列表，在lambda函数体中可以直接使用局部static变量和在它所在函数之外声明的名字  
* 捕获列表可以使用值捕获或者引用捕获，值捕获在lambda创建时拷贝变量，而不是调用时  
* **尽量保持lambda的变量捕获简单化**  
* 混合使用隐式和显示捕获变量时，显示捕获的变量必须使用与隐式捕获不同的方式  
* 默认情况下，如果一个lambda体包含 `return` 之外的任何语句，则编译器自动推断其返回值为  `void` ，需要定义返回类型时，必须使用**尾置返回类型**  
* 对于那种只在**一两个地方**使用的**简单操作**，lambda表达式是最有用的。  
* 标准库 **bind** 函数，定义在头文件 `functional` 中  
* `bind` 接受一个可调用对象，返回一个可调用对象  
* placeholders 占位符
* 使用占位符应该声明一个命名空间 `using namespace std::placeholders`  
* 插入迭代器  

|类型|特点|
|:---:|:---:|
|back_inserter|创建一个使用push_back的迭代器|
|front_inserter|创建一个使用push_front的迭代器|
|inserter|创建一个使用insert的迭代器，第二个参数指向想要操作的容器，inserter创建的迭代器会向其参数位置之前插入元素|

* 根据算法对迭代器操作的要求可以把迭代器分成5类  

|类别|特点|
|:---:|:---:|
|输入迭代器|只读，不写；单遍扫描，只递增|
|输出迭代器|只写，不读；单遍扫描，只递增|
|前向迭代器|可读写；多遍扫描（？？），只递增|
|双向迭代器|可读写；多遍扫描，可递增递减|
|随机访问迭代器|可读写；多遍扫描，支持全部迭代器运算|

# 第十一章 关联容器  
* `map` 是键值对的集合，`set` 是关键字的集合  
* `pair` 定义在头文件 `utility` 中  
* `pair` 的默认构造函数对数据成员进行值初始化  
* 关联容器的额外类型别名  

|别名|特点|
|:---:|:---:|
|key_type|此容器类型的关键字类型|
|mapped_type|每个关键字关联的类型|
|value_type|对于 set ，即 key_type ; 对于 map ，即 pair<const key_type,mapped type>|

* 我们不能改变一个元素的关键字  
* 一个 map 的 value_type 是一个 pair  
* set 的 迭代器是 const 的  
* 通常不对关联容器使用泛型算法  
* map的下标运算符和普通下标运算不太一样，当索引的值不在map中时，下标运算会为它创建一个元素并插入到map中  

> 由于下标运算符可能插入一个新元素，我们只能对非 `const` 的 `map` 使用下标操作  

* 对于 `map` 来说，解引用迭代器和使用下标操作的返回值不同，解引用迭代器返回 `value_type` 对象，下标操作返回 `mapped_type` 对象  
* >有时只是想知道一个元素是否已经在 `map` 中，但在不存在时并不想添加元素，在这种情况下就不能使用下标运算符  

	这种情况下应该使用 `find` 方法  
* 关联容器查找指定元素，有 `find` 和 `count` 方法可以用  
* 无序关联容器使用哈希函数和关键字类型的 `==` 运算符来组织元素  
* 无序容器在存储上组织为一组桶，每个桶保存零个或多个元素  
* 哈希函数负责将指定元素映射到对应的桶，我的理解：哈希函数就是个”垃圾分类工“  
* 对于相同的参数，哈希函数必须产生相同的结果  
* 无序容器对关键字类型有要求  
	具体来说，无序容器的关键字类型可以是内置类型、`string` 和智能指针  
	但是不能直接定义关键字类型为自定义类型的无序容器，原因应该是没有为自定义类型服务的哈希函数吧，这样的哈希函数必须自己提供  

# 第十二章 动态内存  
* 管理动态内存是非常**棘手**的  
* 智能指针（smart pointer） 定义在 memory 头文件中   

|智能指针类型|特点|
|:---:|:---:|
|shared_ptr|允许多个指针指向同一个对象|
|unique_ptr|独占所指向的对象|

* 引用计数（reference count）  
* 当一个 `shared_ptr` 的计数器变为0，他就会自动释放指向的内存  
* >如果将 `shared_ptr` 存放在一个容器中，而后不再需要全部元素，而只使用其中的一部分，要记得用 `erase` 删除不再需要的那些元素  
* 定位 `new` (placement new)  
* `delete` 表达式执行两个动作：销毁给定的指针指向的对象；释放对应的内存  
* 通常情况下，编译器不能分辨一个指针是指向静态还是动态内存，所以请**确保**传递给 `delete` 的指针是指向动态内存的指针或者一个空指针  
* 不能进行内置指针向智能指针的隐式转换，所以类似下面这样的初始化是错误的  
	`shared_ptr<double> p1 = new int(1024);`  
	这样声明并初始化是正确的  
	`shared_ptr<double> p1(new int(1024)); //相当于直接调用构造函数了`  
* 智能指针默认使用 `delete` 释放关联的对象，所以智能指针一般指向动态内存；当然，也可以将智能指针绑定到一个指向其他类型的资源的指针上，前提是我们要提供自己的操作（删除器 `deleter` ）替代 `delete`  
* 尽量不要混合使用内置指针和智能指针  
* 不要使用智能指针的 `get` 方法初始化或为另一个智能指针赋值，因为那有可能造成空悬指针，即指向已经被释放的内存的指针  
* 为了正确使用智能指针，我们必须坚持一些基本规范：  
	* 不使用**相同**的内置指针初始化（或 `reset` ）多个智能指针  
	* 不 `delete` `get` 返回的指针  
	* 不适用 `get()` 初始化或 `reset` 另一个智能指针  
	* 如果使用 `get()` 返回的指针，记住当最后一个对应的那个指针销毁后，你使用的指针就变为无效了（空悬指针）  
	* 如果使用智能指针管理的资源不是 `new` 分配的内存，记住传递给它一个删除器（`deleter`）  

* `unique_ptr` 没有类似 `shared_ptr` 的 `make_shared` 那样的库函数，当我们定义一个 `unique_ptr` 时，必须将其绑定到一个 `new` 返回的指针上，同样的， `unique_ptr` 也必须使用直接初始化，而不能使用隐式转换初始化  
* `unique_ptr` 不支持普通的拷贝或赋值操作  
* `u = nullptr` 释放 u 指向的对象，将 u 置为空  
* 可以使用 `release` 或 `reset` 将指针的所有权从一个 `unique_ptr` 转移给另一个 `unique_ptr`  
* `allocator`  类允许我们将内存分配和初始化分离  
* `allocator` 通常会提供更好的性能和更灵活的内存管理能力  
* 大多数应用应该使用标准库容器而不是动态分配数组。  
* `new int[size]` 方括号中的大小必须是整型，但**不必是常量**  
* 动态分配一个数组时，得到的实际上是一个数组元素类型的指针  
* **不能**使用范围 `for` 语句来处理所谓的动态数组  
* 默认初始化和值初始化  
	`int *pia = new int[10]; //10个默认初始化的int`  
    `int *pia = new int[10](); //10个值初始化的int`  
* `new char[0]` 是合法的，但是不能解引用它返回的指针  
* `unique_ptr<int[]> up(new int[10]);` 使用 `unique_ptr` 指向一个动态分配的数组，指向数组的 `unique_ptr` 不支持成员访问运算符（点和箭头运算符）  
* 由于 `shared_ptr` 默认使用 `delete` 释放关联的对象，所以如果想用 `shared_ptr` 管理动态数组，必须提供自己的删除器  
* 


